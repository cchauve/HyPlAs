
import os
import sys

DEBUG=True
if len(config) == 0:
    configfile: 'config.yaml'



refdir  = "/groups/hachgrp/projects/dev-plasmids/raw-data/ncbi-reference-genomes/eskapee/plasmids"
amira_path  = "/groups/hachgrp/projects/dev-plasmids/analysis/cedar-lr-files"
outpath = config['outpath']
rawdata = config['rawdata']
firstN = -1 if "firstN" not in config else config["firstN"]
PLASMID_SAVE_ITER = 2


#config['tools'] = ['plassembler', 'skesa', 'unicycler-sr']

#config['tools'] = ['skesa', 'unicycler-sr']
config['sra'] = ['unicycler']
config['lra'] = ['unicycler']
config['pcc'] = ['platon']


def generate_fasta(fasta):
    name = "NULL"
    seq = list()
    if fasta.endswith(".gz"):
        f = gzip.open(fasta, "rt")
    else:
        f = open(fasta, "r")
    header = "NULL"
    for _, l in enumerate(f):
        l = l.rstrip("\n")
        if l[0] == ">":
            if len(seq) == 0:
                name = l[1:].split(" ")[0]
                header = " ".join(l.split(" ")[1:])
                continue
            yield (name, header,"".join(seq))
            seq = list()
            name = l[1:].split(" ")[0]
            header =  " ".join(l.split(" ")[1:])

        else:
            seq.append(l)
    yield (name, header,"".join(seq))

def absolute_file_paths(directory):
    path = os.path.abspath(directory)
    return [entry.path for entry in os.scandir(path) if entry.is_file()]

def load_from_tsv(tsv_file):
    import pandas as pd
    blacklisted = set()
    for line in open("blacklist.txt"):
        blacklisted.add(line.strip())
    df = pd.read_csv(tsv_file, sep='\t')
    if 'samples' not in config:
        config['samples'] = {}
    for i, row in df.iterrows():
        nom = row['Assembly BioSample Accession']
        if nom in blacklisted:
            continue
        if pd.isna( row['SRA Accession']):
            continue
        p2a = {x.split(":")[0]:x.split(":")[1] for x in row['SRA Accession'].split("; ")[1:]}

        if 'OXFORD_NANOPORE' not in p2a:
            #print(f"{nom} doesn't have OXFORD_NANOPORE accession")
            continue
        if 'ILLUMINA' not in p2a:
            #print(f"{nom} doesn't have ILLUMINA accession")
            continue
#        if not os.path.isfile(f"{amira_path}/{nom}.amira.gfa"):
#            continue
        if not os.path.isfile(f"{rawdata}/ILLUMINA/{nom}/{p2a['ILLUMINA']}_2.fastq.gz"):
            continue
        if not os.path.isfile(f"{refdir}/{nom}.fasta"):
            continue
        config['samples'][nom] = {
            'lr': f"{rawdata}/OXFORD_NANOPORE/{nom}/{p2a['OXFORD_NANOPORE']}_1.fastq.gz",
            'sr': [f"{rawdata}/ILLUMINA/{nom}/{p2a['ILLUMINA']}_1.fastq.gz",
                    f"{rawdata}/ILLUMINA/{nom}/{p2a['ILLUMINA']}_2.fastq.gz"
                   ],
            'sr-path' : f"{rawdata}/ILLUMINA/{nom}/",
            'lr-path' : f"{rawdata}/OXFORD_NANOPORE/{nom}/"
        }
        if firstN > 0 and i > firstN:
            break


if "tsv" in config:
    load_from_tsv(config['tsv'])

def get_sample_lr(wildcards):
    return config["samples"][wildcards.sample]["lr"]
def get_sample_sr(wildcards):
    return config["samples"][wildcards.sample]["sr"]
def get_sample_sr1(wildcards):
    return sorted(absolute_file_paths(config["samples"][wildcards.sample]["sr-path"]))[0]
def get_sample_sr2(wildcards):
    return sorted(absolute_file_paths(config["samples"][wildcards.sample]["sr-path"]))[1]
def get_sample_sr(wildcards):
    return absolute_file_paths(config["samples"][wildcards.sample]["sr-path"])[:2]

def get_sample_lr(wildcards):
    return absolute_file_paths(config["samples"][wildcards.sample]["lr-path"])[0]

if DEBUG:
    def pipe(X):
        return X
    def temp(X):
        return X

plasmid_classifier="plasgraph2"

rule all:
    input:
        #        expand(f"{outpath}/{{sample}}/from_amira/assembly.final.fasta", sample=config["samples"]),
        #expand(f"{outpath}/{{sample}}/hyplass_u{{it}}/assembly.final.fasta", sample=config["samples"], it=[0,1,2]),
        #expand(f"{outpath}/{{sample}}/hyplass_b/assembly.final.it{{it}}.fasta", sample=config["samples"], it=[0,1,2]),
        #expand(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/final_gc.circular.fasta", sample=config["samples"], sra=config["sra"], lra=config["lra"], pcc=config["pcc"]),
        expand(f"{outpath}/{{sample}}/hyplass_b_cov/plasmid_selected_i{{iter}}.coverage.tsv", sample=config["samples"], iter=[0,1,2]),

rule all_assembly_qc:
    input:
        expand(f"{outpath}/{{sample}}/qc/assembly/magpie-raven/assembly.circular.fasta", sample=config["samples"]),

rule all_selection_qc:
    input:
        expand(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected.gaf", sample=config["samples"], sra=config["sra"], pcc=config["pcc"]),

rule all_plassembler:
    input:
        expand(f"{outpath}/{{sample}}/plassembler_flye/plassembler_plasmids.fasta",sample=config["samples"]),

rule all_unicycler_lra_conservative:
    input:
        expand(f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_c{PLASMID_SAVE_ITER}/assembly.circular.fasta", sample= config["samples"], pcc=["plat_minus_plas"]),

rule all_unicycler_lra_bold:
    input:
        expand(f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_b{PLASMID_SAVE_ITER}/assembly.circular.fasta", sample= config["samples"], pcc=["plat_minus_plas"]),
rule all_unicycler_lra:
    input:
        expand(f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_i{{it}}/assembly.circular.fasta", it=[i for i in range(2)], sample= config["samples"], pcc=["platon"]),

rule all_stats:
    input:
        #   expand(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected{{pu}}.coverage.tsv",sample=config["samples"], sra=config["sra"], lra=config["lra"], pcc=config["pcc"], pu =["","_pu"]),
        expand(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected_i{{iter}}{{pu}}.coverage.tsv",sample=config["samples"], sra=config["sra"], lra=config["lra"], pcc=["platon"], iter=[0,1,2], pu =["","_pu"]),
        #expand(f"{outpath}/{{sample}}/qc/toplasmids.coverage.tsv",sample=config["samples"]),
        #expand(f"{outpath}/{{sample}}/plassembler{{flye}}-qc/toplasmids.coverage.tsv",sample=config["samples"], flye=["","_flye"]),

rule gfatools_unitigs:
    input:
        "{sample}.gfa"
    output:
        "{sample}.unitigs.gfa"
    shell:
        "gfatools asm -u {input}  > {output}"

rule replace_unitig_names_with_numbers:
    input:
        "{sample}.unitigs.gfa"
    output:
        "{sample}.nunitigs.gfa"
    run:
        with open(input[0], 'r') as rh, open(output[0], 'w') as wh:
            utg_idx = {}
            idx     = 1
            for line in rh:
                if line[0] == "S":
                    line = line.rstrip().split("\t")
                    utg_idx[line[1]] = idx
                    line[1] = f"{idx}"
                    idx+=1
                    print("\t".join(line), file=wh)
                elif line[0] == "L":
                    line = line.rstrip().split("\t")
                    line[1] = str(utg_idx[line[1]])
                    line[3] = str(utg_idx[line[3]])
                    print("\t".join(line), file=wh)
                    

rule unnamed_assembler_from_amira:
    input:
        binary = "src/main.py",
        lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
        gfa = f"{amira_path}/{{sample}}.amira.nunitigs.gfa",
    output:
        dir=directory(f"{outpath}/{{sample}}/from_amira/"),
        fa=f"{outpath}/{{sample}}/from_amira/assembly.final.fasta",
    threads:
        32
    params:
        iter=1,
        db="../../annotation/db"
    resources:
        runtime=lambda wc, attempt: attempt * 6 * 60 - 1,
        mem_mb=1024*250, 
    shell:
        "python {input.binary}"
        " -l {input.lr}"
        " -o {output.dir}"
        " --platon-db {params.db}"
        " -p {params.iter}"
        " -t {threads}"
        " --sr-assembly {input.gfa}"
        " --force"

rule unnamed_assembler_from_existing_assembly:
    input:
        binary = "src/main.py",
        lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
        gfa = f"{outpath}/{{sample}}/sra-unicycler/assemble/002_depth_filter.gfa",
#        gfa = f"{outpath}/{{sample}}/sra-unicycler/assemble/assembly.gfa",
    output:
        dir=directory(f"{outpath}/{{sample}}/hyplass_bont_u{{it}}/"),
        fa=f"{outpath}/{{sample}}/hyplass_bont_u{{it}}/assembly.final.fasta",
    threads:
        16
    benchmark:
        f"{outpath}/benchmarks/{{sample}}.hyplass_from_assembly_i{{it}}.benchmark.txt"
    params:
        iter=lambda wildcards: wildcards.it,
        db="../../annotation/db"
    resources:
        runtime=lambda wc, attempt: attempt * 6 * 60 - 1,
        mem_mb=1024*120, 
    shell:
        "python {input.binary}"
        " -l {input.lr}"
        " -o {output.dir}"
        " --platon-db {params.db}"
        " -p {params.iter}"
        " -t {threads}"
        " --sr-assembly {input.gfa}"
        " --force"

rule unnamed_assembler:
    input:
        src = "src/main.py",
        lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
        sr = [f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz",
f"{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz"],
    output:
        dir=directory(f"{outpath}/{{sample}}/hyplass_b/"),
     #   plasmid_base =f"{outpath}/{{sample}}/hyplass_b/plasmid_long_reads/plasmid.fastq.gz",
     #   plasmid_extension =[f"{outpath}/{{sample}}/hyplass_b/prop_lr/lr.round.{it}.fastq.gz" for it in range(2)],
        fa=[f"{outpath}/{{sample}}/hyplass_b/assembly.final.it{it}.fasta" for it in range(3)],
    threads:
        32
    params:
        iter=2,
        db="../../annotation/db"
    resources:
        runtime=lambda wc, attempt: attempt * 6 * 60 - 1,
        mem_mb=1024*88, 
    shell:
        "python {input.src}"
        " -l {input.lr}"
        " -o {output.dir}"
        " --platon-db {params.db}"
        " -p {params.iter}"
        " -t {threads}"
        " -s {input.sr}"
        " --force"

"""
rule find_circular_plasmids:
    input:
        f"{outpath}/{{sample}}/{{gfa}}.gfa"
    output:
        fasta=f"{outpath}/{{sample}}/{{gfa}}.circular.fasta",
        tsv=f"{outpath}/{{sample}}/{{gfa}}.summary.tsv",
    params:
        save_large_cycles=False,
        min_ctg_len=1000,
    run:
        import gfapy
        import networkx as nx
        def sanitize_gfa(line):
            if line[0] == "S":
                line = line.rstrip().split("\t")
                return "\t".join([line[0],line[1],line[2],f"KC:i:{int(float(line[3][5:]))}"])
            else:
                return line
        g = gfapy.Gfa([sanitize_gfa(line) for line in open(input[0],'r')])

        edge_set = {(x.from_name, x.to_name)for x in g.edges}
        G = nx.Graph()
        if params.save_large_cycles:
            with open(output.fasta, 'w') as fhand, open(output.tsv, 'w') as thand:
                for a,b in edge_set:
                    if a==b:
                        print(f">{a}\n{g.segment(a).sequence}",file=fhand)
                        print("\t".join([
                            a,
                            str(len(g.segment(a).sequence)),
                            "single",
                            ]), file=thand)
                    else:
                        G.add_edge(a,b)
                while True:
                    a = sorted(list(nx.simple_cycles(G)), key = lambda s: len(s))
                    new_contig = []
                    new_contig_name = []
                    try:
                        if len(a) > 0:
                            for c in a[-1]:
                                new_contig.append(g.segment(c).sequence)
                                new_contig_name.append(c)               #TODO fix stranding
                                G.remove_node(c)
                        else:
                            break

                        ctg_name = "-".join(new_contig_name)
                        ctg_seq = ''.join(new_contig)
                        print(f">{ctg_name}\n{ctg_seq}",file=fhand)
                        print("\t".join([
                            ctg_name,
                            str(len(ctg_seq)),
                            "joined",
                            ]), file=thand)
                    except:
                        break
        else:
            with open(output.fasta, 'w') as fhand, open(output.tsv, 'w') as thand:
                for a,b in edge_set:
                    if a==b and len(g.segment(a).sequence) > params.min_ctg_len:
                        print(f">{a}\n{g.segment(a).sequence}",file=fhand)
                        print("\t".join([
                            a,
                            str(len(g.segment(a).sequence)),
                            "single",
                            ]), file=thand)
"""


rule combine_results:
    input:
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/correction/pilon.fasta",
        sr_fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/sr-contigs.fasta",
    output:
        f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/final.fasta",
    shell:
        "cat {input.fasta} {input.sr_fasta} > {output}"

db_path = f"{outpath}/plassembler-db/"

rule Plassembler_flye:
    input:
        lr = get_sample_lr,
#        sr1 = get_sample_sr1,
#        sr2 = get_sample_sr2,
        sr = get_sample_sr,
        db = f"{db_path}"
    output:
        out_dir = temp(directory(f"{outpath}/{{sample}}/plassembler_flye")),
        fasta = f"{outpath}/{{sample}}/plassembler_flye/plassembler_plasmids.fasta",
        summary = f"{outpath}/{{sample}}/plassembler_flye/plassembler_summary.tsv",
        plasmid_fastq = f"{outpath}/{{sample}}/plassembler_flye/plasmid_fastqs/plasmids_long.fastq",
    params:
        par = "-c 1000000",
        sr_param = lambda wildcards: " ".join([f"-{i} {x}" for i,x in enumerate(get_sample_sr(wildcards), start=1)])
    threads:
        64
    resources:
        runtime=lambda wc, attempt: attempt * 6 * 60 - 1,
        mem_mb=1024*700, 
    benchmark:
        f"{outpath}/{{sample}}/plassembler_flye.benchmark.tsv"
    shell:
        "plassembler run {params.sr_param}"
        " -l {input.lr}"
        " -d {input.db}"
        " -o {output.out_dir} --force"
        " -t {threads}"
        " {params.par}"
        " --keep_fastqs"



rule Plassembler:
    input:
        lr = get_sample_lr,
#        sr1 = get_sample_sr1,
#        sr2 = get_sample_sr2,
        sr = get_sample_sr,
        db = f"{db_path}"
    output:
        out_dir = temp(directory(f"{outpath}/{{sample}}/plassembler")),
        fasta = f"{outpath}/{{sample}}/plassembler/plassembler_plasmids.fasta",
        summary = f"{outpath}/{{sample}}/plassembler/plassembler_summary.tsv",
        plasmid_fastq = f"{outpath}/{{sample}}/plassembler/plasmid_fastqs/plasmids_long.fastq",
    params:
        par = "-c 1000000 --use_raven",
        sr_param = lambda wildcards: " ".join([f"-{i} {x}" for i,x in enumerate(get_sample_sr(wildcards), start=1)])
    threads:
        64
    resources:
        runtime=lambda wc, attempt: attempt * 6 * 60 -1,
        mem_mb=1024*700, 
    benchmark:
        f"{outpath}/{{sample}}/plassembler.benchmark.tsv"
    shell:
        "plassembler run {params.sr_param}"
        " -l {input.lr}"
        " -d {input.db}"
        " -o {output.out_dir} --force"
        " -t {threads}"
        " {params.par}"
        " --keep_fastqs"



rule plassembler_download_db:
    output:
        directory(f"{db_path}"),
    shell:
        "plassembler download -d {output}"
rule make_final_gfa:
    input:
        gfa = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/lr-assembly.gfa",
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/correction/pilon.fasta",
        sr_gfa = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/sr-contigs.gfa",
    output:
        gfa = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/final.gfa",
    shell:
        "python src/collect_gfa.py"
        " {input.gfa}"
        " {input.fasta}"
        " {input.sr_gfa}"
        " {output.gfa}"


rule make_final_gfa2:
    input:
        s1=f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz",
        s2=   f"{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/final.fasta",
    output:
        gfa = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/final_gc.gfa",
    threads:
        32
    params:
        reads= f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz,{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
    shell:
        "gfa_connector"
        " --reads {params.reads}"
        " --contigs {input.fasta}"
        " --gfa {output.gfa}"
        " --cores {threads}"
        " --use_paired_ends"


rule make_skesa_gfa:
    input:
        s1=f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz",
        s2=   f"{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
        fasta = f"{outpath}/{{sample}}/sra-skesa/assemble/assembly.fasta", 
    output:
        gfa=f"{outpath}/{{sample}}/sra-skesa/assemble/assembly.gfa",
        csv=f"{outpath}/{{sample}}/sra-skesa/assemble/assembly.csv",
    threads:
        32
    params:
        reads= f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz,{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
    shell:
        "gfa_connector"
        " --reads {params.reads}"
        " --contigs {input.fasta}"
        " --gfa {output.gfa}"
        " --csv {output.csv}"
        " --cores {threads}"
        " --use_paired_ends"

rule skesa:
    input:
        f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz",
        f"{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
    output:
        fasta = f"{outpath}/{{sample}}/sra-skesa/assemble/assembly.fasta", 
    params:
        reads= f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz,{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
        memory="256",
    threads:
        64
    resources:
        runtime=6*60-1 
    shell:
       "skesa "
        " --reads {params.reads}"
        " --cores {threads}"
        " --memory {params.memory}"
        " > {output.fasta}"

rule extract_missing_long_reads:
    input:
        lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
        paf = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.{{iter}}.paf",
        gaf = f"{outpath}/{{sample}}/sra-{{sra}}/minigraph/lr2sra.gaf",
        tsv = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/classify/result_p.tsv",
    output:
        lr = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.{{iter}}.fastq.gz",
    shell:
        "./src/select_missing_reads"
        " {input.paf}"
        " {input.gaf}"
        " {input.lr}"
        " {output.lr}"
        " {input.tsv}"

for iter in range(PLASMID_SAVE_ITER):
    rule :
        input:
            lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
            lr_plasmid = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.fastq.gz",

            prev = [f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.{i}.fastq.gz" for i in range(iter+1)],
        output:
            paf = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.{iter+1}.paf",
        threads:
            32
        shell:
            "minimap2"
            " <( ../bio/build/bin/innotin {input.lr} <(cat {input.lr_plasmid} {input.prev}))"
            " {input.lr_plasmid}"
            " {input.prev}"
            " -o {output.paf}"
            " -t {threads}"
rule find_missing_long_reads:
    input:
        lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
        lr_plasmid = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.fastq.gz",
    output:
        paf = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.0.paf",
    threads:
        64
    shell:
        "minimap2"
        " <( ../bio/build/bin/innotin {input.lr} {input.lr_plasmid})"
        " {input.lr_plasmid}"
        " -o {output.paf}"
        " -t {threads}"

rule pick_unicycler_complete_contigs:
    input:
        f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_{{i}}{{piter}}/assembly.fasta",
    output:
        f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_{{i}}{{piter}}/assembly.circular.fasta",
    params:
        max_length_plasmid = 1_500_000,
    run:
        with open(output[0], 'w') as hand:
            for n,h,s in generate_fasta(input[0]):
                if "circular" in h and len(s) < params.max_length_plasmid:
                    print(f">{n} {h}\n{s}", file=hand)


rule continue_unicycler:
    input:
        assembly = f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_{{i}}{{piter}}",
        sr1 = f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz",
        sr2 = f"{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
        lr_plasmid = f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/select-lr/plasmid.fastq.gz",
        lr_plasmid2 = lambda w: [f"{outpath}/{w.sample}/sra-unicycler/pcc-{w.pcc}/select-lr/plasmid.{i}.fastq.gz" for i in range(int(w.piter))],
        lr_unknown = f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/select-lr/unknown.fastq.gz",
    output:
        combined_lr =temp(f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/select-lr/combined_{{i}}{{piter}}.fastq.gz"),
        done = f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_{{i}}{{piter}}.done",
        fasta = f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_{{i}}{{piter}}/assembly.fasta",
    threads:
        64
    params:
        par = "",
        is_bold=lambda w: "--mode=bold" if w.i == "b" else "--mode=conservative" if w.i == "c" else ""
    resources:
        runtime=lambda wc,attempt:(attempt*4)*6*60-1 
    shell:
        "zcat {input.lr_plasmid}"
        " {input.lr_plasmid2}"
        " {input.lr_unknown}"
        " | pigz -p {threads} > {output.combined_lr} &&"
        ""
        " unicycler -1 {input.sr1}"
        " -2 {input.sr2}"
        " -l {output.combined_lr}"
        " -o {input.assembly}"
        " -t {threads}"
        " {params.is_bold}"
        " {params.par} && touch {output.done}"

rule copy_unicycler_sr:
    input:
        f"{outpath}/{{sample}}/sra-unicycler/assemble",
    output:
        directory(f"{outpath}/{{sample}}/sra-unicycler/pcc-{{pcc}}/lra-unicycler_{{i}}{{piter,[0-9]+}}"),
    shell:
        "cp -r {input} {output} && rm {output}/assembly.fasta {output}/assembly.gfa"

rule unicycler_sr:
    input:
        sr1 = f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz",
        sr2 = f"{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
    output:
        out_dir = temp(directory(f"{outpath}/{{sample}}/sra-unicycler/assemble")),
        fasta = f"{outpath}/{{sample}}/sra-unicycler/assemble/assembly.fasta",
        gfa = f"{outpath}/{{sample}}/sra-unicycler/assemble/assembly.gfa",
    params:
        par = "",
    threads:
        64
    resources:
        runtime=lambda wc,attempt:(attempt*4)*6*60-1 
    shell:
        "unicycler -1 {input.sr1}"
        " -2 {input.sr2}"
        " -o {output.out_dir}"
        " -t {threads}"
        " {params.par}"
    
rule fastp:
    input:
        sr1 = get_sample_sr1,
        sr2 = get_sample_sr2,
    output:
        sr1 = f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz",
        sr2 = f"{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz",
        unpaired = f"{outpath}/{{sample}}/qc/{{sample}}.unpaired.fastq.gz",
    params:
        par = "",
    threads:
        16
    resources:
        runtime=60,
        mem_mb=1024*8,

    shell:
        "fastp --in1 {input.sr1} --in2 {input.sr2}"
        " --out1 {output.sr1} --out2 {output.sr2}"
        " --unpaired1 {output.unpaired}"
        " --unpaired2 {output.unpaired}"
        " --thread {threads}"
        " {params.par}"


rule platon_plus_plasgraph2_negative:
    input:
        plat = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify/result_p.tsv",
        plas = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2/classify/result.csv",
    output:
        tsv =  f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plat_minus_plas/classify/result_p.tsv",
    threads:
        2
    params:
        max_plas_score = 0.01,
        min_chro_score = 0.99,
    run:
        import pandas as pd
        A = {str(x) for x in pd.read_csv(input.plat, sep="\t").ID}
        df = pd.read_csv(input.plas, sep=",").set_index('contig')

        df = df.loc[df.chrom_score >= params.min_chro_score]
        df = df.loc[df.plasmid_score < params.max_plas_score]
        B = {str(x) for x in df.index}
        with open(output.tsv, 'w') as hand:
            print("ID\tPREDICTION",file=hand)
            for ctg in A:
                print(f"{ctg}\tplasmid",file=hand)
            for ctg in B - A:
                print(f"{ctg}\tchromosome",file=hand)
        
rule platon_plus_plasgraph2_strict:
    input:
        plat = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify/result.tsv",
        plas = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2_strict/classify/result.tsv",
    output:
        tsv =  f"{outpath}/{{sample}}/sra-{{tool}}/pcc-ppunion/classify/result.tsv",
    run:
        import pandas as pd
        A = {str(x) for x in pd.read_csv(input.plat, sep="\t").ID}
        B = {str(x) for x in pd.read_csv(input.plas, sep="\t").ID}
        with open(output.tsv, 'w') as hand:
            print("ID\tPREDICTION",file=hand)
            for ctg in A | B:
                print(f"{ctg}\tplasmid",file=hand)
        
rule process_plasgraph:
    input:
        csv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2/classify/result.csv",
    output:
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2/classify/result_p.tsv",
    run:
        import pandas as pd
        df = pd.read_csv(input.csv)
        with open(output.tsv, 'w') as hand:
            print("ID\tPREDICTION", file=hand)
            for i,d in df.iterrows():
                print(f"{d.contig}\t{d.label}", file=hand)

rule plasgraph2_strict:
    input:
        gfa = f"{outpath}/{{sample}}/sra-{{tool}}/assemble/assembly.gfa", 
    output:
        csv = temp(f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2_strict/classify/result.csv"),
        tsv = temp(f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2_strict/classify/result.tsv"),
    shell:
        "CUDA_VISIBLE_DEVICES=''"
        " micromamba run -n plasgraph-env"
        " python ./ext/plASgraph2/src/plASgraph2_classify.py"
        " gfa"
        " {input.gfa}"
        " ext/plASgraph2/model/ESKAPEE_model/"
        " {output.csv} && cat {output.csv} && cat {output.csv} |  tr ',' '\\t' | sed 's/contig/ID/g' |grep plasmid | cut -f 2,6 > {output.tsv}"


rule plasgraph2:
    input:
        gfa = f"{outpath}/{{sample}}/sra-{{tool}}/assemble/assembly.gfa", 
    output:
        csv = temp(f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2/classify/result.csv"),
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2/classify/result.tsv",
    shell:
        "CUDA_VISIBLE_DEVICES=''"
        " micromamba run -n plasgraph-env"
        " python ./ext/plASgraph2/src/plASgraph2_classify.py"
        " gfa"
        " {input.gfa}"
        " ext/plASgraph2/model/ESKAPEE_model/"
        " {output.csv} && cat {output.csv} && cat {output.csv} |  tr ',' '\\t' | sed 's/contig/ID/g' |grep -v chromosome | cut -f 2,6 > {output.tsv}"

rule generate_plasgraph2_plasmid_contigs:
    input:
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2/classify/result.tsv",
        fasta = f"{outpath}/{{sample}}/sra-{{tool}}/assemble/assembly.fasta",
    output:
        fasta = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-plasgraph2/classify/result.plasmid.fasta",
    run:
        import pandas as pd
        df = {str(x) for x in pd.read_csv(input.tsv, sep="\t").ID}
        
        with open(output.fasta, 'w') as hand:
            for n,h,c in generate_fasta(input.fasta):
                if n in df:
                    print(f">{n} {h}\n{c}", file=hand)

rule process_platon_old:
    input:
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify/result.tsv",
    output:
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify/result_po.tsv",
    run:
        import pandas as pd
        df = pd.read_csv(input.tsv, sep="\t")
        with open(output.tsv, 'w') as hand:
            print("ID\tPREDICTION", file=hand)
            for i,d in df.iterrows():
                print(f"{d.ID}\tplasmid", file=hand)
rule process_platon:
    input:
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify/result.tsv",
    output:
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify/result_p.tsv",
    params:
        max_chr_rds=-7.9,
        min_plasmid_rds=0.7,
    run:
        import pandas as pd
        import numpy as np
        df = pd.read_csv(input.tsv, sep="\t")

        chr_pos = df.RDS<=params.max_chr_rds
        pls_pos = df.RDS>=params.min_plasmid_rds
        rest = ~np.logical_or(chr_pos, pls_pos)
        can_circl = df.Circular=="yes"
        incopat   = df["Inc Type(s)"]>0
        repmob    = (df["# Replication"] + df["# Mobilization"]) > 0
        orit      = df["# OriT"] > 0
        hit       = np.logical_and(np.logical_and(df.RDS > 0.5, df["# Plasmid Hits"] >0), df["# rRNAs"] == 0)
        with open(output.tsv, 'w') as hand:
            print("ID\tPREDICTION", file=hand)
            for i,d in df.loc[pls_pos].iterrows():
                print(f"{d.ID}\tplasmid", file=hand)
            for i,d in df.loc[rest & (can_circl | incopat | repmob | orit | hit)].iterrows():
                print(f"{d.ID}\tplasmid", file=hand)
            for i,d in df.loc[df.RDS<=params.max_chr_rds].iterrows():
                print(f"{d.ID}\tchromosome", file=hand)
rule platon:
    input:
        fasta = f"{outpath}/{{sample}}/sra-{{tool}}/assemble/assembly.fasta", 
    output:
        dir = directory(f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify"),
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify/result.tsv",
        fasta = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-platon/classify/result.plasmid.fasta",
    threads:
        16
    resources:
        runtime=6*60-1
    params:
        db="/groups/hachgrp/projects/dev-plasmids/annotation/db"
    shell:
        "platon"
        " --db {params.db}"
        " {input.fasta}"
        " --output {output.dir}"
        " -t {threads}"
        " --prefix result"
        " -c"


rule rfplasmid_Generic: #TODO species identification  from reference tsv!
    input:
        fasta = f"{outpath}/{{sample}}/sra-{{tool}}/assemble/assembly.fasta", 
    output:
        dir = directory(f"{outpath}/{{sample}}/sra-{{tool}}/pcc-rfplasmid/classify"),
        tsv = f"{outpath}/{{sample}}/sra-{{tool}}/pcc-rfplasmid/classify/result.tsv",
    output:
        dir = directory(f"{outpath}/{{sample}}/rfplasmid/{{assembler}}/"),
    threads:
        16
    shell:
        "micromamba run -n rfplasmid"
        " rfplasmid"
        " --species Generic"
        " --input {input.fasta}"
        " --out {output.dir}"
        " --threads {threads}"
        " --jelly"


rule chopper_lr:
    input:
        get_sample_lr,
    output:
        lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
    params:
        minqual=9,
        minlen=500,
        headcrop=75,
        tailcrop=75,
    threads:
        32
    shell:
        "chopper"
        " -q {params.minqual}"
        " --threads {threads}"
        " -l {params.minlen}"
        " --headcrop {params.headcrop}"
        " --tailcrop {params.tailcrop}"
        " --input {input}" 
        " | pigz > {output.lr}"

rule MG_lr_reads_Trimmed:
    input:
        lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
        gfa = f"{outpath}/{{sample}}/sra-{{sra}}/assemble/assembly.gfa",
    output:
        gaf = f"{outpath}/{{sample}}/sra-{{sra}}/minigraph/lr2sra.gaf",
    threads:
        64
    shell:
        "minigraph "
        " {input.gfa}"
        " {input.lr}"
        " -t {threads}"
        " -x lr -c "
        " > {output.gaf}"

rule assemble_selected_reads_with_magpie_GT:
    input:
        lr_plasmid = f"{outpath}/{{sample}}/qc/toplasmids.fq.gz",
    output:
        fasta = f"{outpath}/{{sample}}/qc/assembly/magpie-{{lra}}/assembly.fasta",
        gfa = f"{outpath}/{{sample}}/qc/assembly/magpie-{{lra}}/assembly.gfa"
    threads:
        64
    params:
        lr_assembler= lambda w: w.lra,
    resources:
        runtime=6*60-1,
        mem_mb="256G",
    shell:
        "python3"
        " src/magpie.py"
        " --threads {threads}"
        " {params.lr_assembler}"
        " {input.lr_plasmid}"
        " -F {output.gfa}"
        " -O {output.fasta}"

rule assemble_selected_reads_with_magpie:
    input:
        lr_plasmid = [f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.fastq.gz",
        f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.0.fastq.gz",
        f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/unknown.fastq.gz"],
    output:
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/lr-assembly.fasta",
        gfa = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/lr-assembly.gfa",
    threads:
        64
    params:
        lr_assembler= lambda w: w.lra,
    resources:
        runtime=6*60-1,
        mem_mb="256G",
    shell:
        "python3"
        " src/magpie.py"
        " --threads {threads}"
        " {params.lr_assembler}"
        " {input.lr_plasmid}"
        " -F {output.gfa}"
        " -O {output.fasta}"

rule recover_sr_only_all:
    input:
        gfa = f"{outpath}/{{sample}}/sra-{{sra}}/assemble/assembly.gfa",
        tsv = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/classify/result.tsv",
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/lr-assembly.fasta",
    output:
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/sr-contigs-all.fasta",
    threads:
        4
    resources:
        runtime=6*60-1,
        mem_mb="16G",
    shell:
        "python3"
        " src/recover_sr.py"
        " --threads {threads}"
        " -T {input.platon_tsv}"
        " -G {input.sr_gfa}"
        " -L {input.lr_fasta}"
        " -SO {output.sr_fasta}"
rule recover_sr_only_predicted:
    input:
        gfa = f"{outpath}/{{sample}}/sra-{{sra}}/assemble/assembly.gfa",
        tsv = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/classify/result.tsv",
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/lr-assembly.fasta",
    output:
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/sr-contigs.fasta",
        gfa = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/sr-contigs.gfa",
    threads:
        4
    resources:
        runtime=6*60-1,
        mem_mb="16G",
    shell:
        "python3"
        " src/recover_sr.py"
        " --threads {threads}"
        " -T {input.tsv}"
        " -G {input.gfa}"
        " -L {input.fasta}"
        " -SO {output.fasta}"
        " -GO {output.gfa}"
        " --only_pick_plasmid_predicted_circular"


rule pilon_correction:
    input:
        bam = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/bwa/sr2lrc.bam",
        bai = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/bwa/sr2lrc.bam.bai",
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/lr-assembly.fasta",
    output:
        dire = directory(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/correction/"),
        fasta = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/correction/pilon.fasta",
    shell:
        "pilon"
        " --genome {input.fasta}"
        " --frags {input.bam}"
        " --outdir {output.dire}"

rule bwa_index:
    input:
        f"{outpath}/{{genome}}.fasta"
    output:
        idx=multiext(f"{outpath}/{{genome}}.{{alg}}", ".amb", ".ann", ".bwt", ".pac", ".sa"),
    log:
        "logs/bwa_index/{genome}.{alg}.log",
    params:
        extra="",
    wrapper:
        "v3.13.8/bio/bwa/index"

rule bwa_mem:
    input:
        reads = [ f"{outpath}/{{sample}}/qc/{{sample}}.sr1.fastq.gz", f"{outpath}/{{sample}}/qc/{{sample}}.sr2.fastq.gz"],
        idx=multiext(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/lr-assembly.fasta", ".amb", ".ann", ".bwt", ".pac", ".sa"),
    output:
        temp(
            f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/bwa/sr2lrc.bam"
            ),
    log:
        "logs/bwa_mem/{sample}_{sra}_{pcc}_{lra}.log",
    params:
        extra=r"-R '@RG\tID:{sample}\tSM:{sample}'",
        sorting="samtools",  # Can be 'none', 'samtools' or 'picard'.
        sort_order="coordinate",  # Can be 'queryname' or 'coordinate'.
        sort_extra="",  # Extra args for samtools/picard.
    threads: 64
    resources:
        time = lambda wc, attempt: (attempt* 6)
    wrapper:
        "v3.13.8/bio/bwa/mem"

rule samtools_index:
    input:       
        f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/bwa/sr2lrc.bam"
    output:
        f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/lra-{{lra}}/bwa/sr2lrc.bam.bai"
    log:
        "logs/samtools_index/{sample}_{sra}_{pcc}_{lra}.log",
    params:
        extra="",  # optional params string
    threads: 16  # This value - 1 will be sent to -@
    wrapper:
        "v3.13.8/bio/samtools/index"

def getrecord(reads):
    head = reads.readline().rstrip()
    while head:
        if not head:
            return None
        seq = reads.readline().rstrip()
        c = reads.readline().rstrip()
        qual = reads.readline().rstrip()
        yield (head, seq, c, qual)
        head = reads.readline().rstrip()

        
def parse_gaf_line(line):
    line = line.rstrip().split("\t")
    qid = line[0]

    qlen = int(line[1])
    qstart = int(line[2])
    qend   = int(line[3])
    orient = line[4]

    # links = anysplit(line[5], "<>")[1:]
    links = line[5].replace(">", '<').split("<")[1:]
    return (qid, links)
def get_graph_alignment(gaf_file):
    current = None
    for line in gaf_file:
        it = parse_gaf_line(line)
        if not it:
            continue
        result = []
        if current !=None:
            result.extend(current[1])
        while current == None or current[0] == it[0]:
            result.extend(it[1])
            current = it
            _next = gaf_file.readline()
            if not _next:
                break
            it = parse_gaf_line(_next.rstrip())
        yield (current[0], result)
        current = it
rule split_reads_plasmid_chr:
    input:
        gaf = f"{outpath}/{{sample}}/sra-{{sra}}/minigraph/lr2sra.gaf",
        lr = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
        tsv = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/classify/result_p.tsv",
    output:
        lr_plasmid = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.fastq.gz",
        lr_unknown = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/unknown.fastq.gz",
#        lr_chromos = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/chromosome.fastq.gz",
    resources:
        runtime=6*60-1
    threads:
        4
    shell:
        "./src/split_plasmid_reads"
        " {input.gaf}"
        " {input.lr}"
        " {input.tsv}"
        " {output.lr_plasmid}"
        " skip"
        " {output.lr_unknown}"


rule minigraph2GT:
    input:
        fasta=f"{outpath}/{{sample}}/GT/plasmid.circularized.gfa",
        lr_plasmid = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.fastq.gz",
    output:
        f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected.gaf",
    threads:
        64
    shell:
        "minigraph "
        " {input.fasta}"
        " {input.lr_plasmid}"
        " -t {threads}"
        " -x lr -c "
        " > {output}"

rule samtoolscoverageforgt:
    input:
        bam=f"{outpath}/{{file}}.bam",
    output:
        tsv=f"{outpath}/{{file}}.coverage.tsv",
    shell:
        "samtools coverage {input.bam} > {output.tsv}"

rule minimapPlassembler2GT:
    input:
        filter_bin = "src/filter_plasmid_sam.py", 
        ref= f"{refdir}/{{sample}}.fasta",
        ctgs = f"{outpath}/{{sample}}/plassembler{{is_flye}}/plasmid_fastqs/plasmids_long.fastq",
    output:
        sam=f"{outpath}/{{sample}}/plassembler{{is_flye}}-qc/toplasmids.sam",
        samf=f"{outpath}/{{sample}}/plassembler{{is_flye}}-qc/toplasmids_filtered.sam",
        bam=f"{outpath}/{{sample}}/plassembler{{is_flye}}-qc/toplasmids.bam",
    threads:
        64
    wildcard_constraints: is_flye=".*"
    shell:
        "minimap2"
        " {input.ref}"
        " {input.ctgs}"
        " -t {threads}"
        " -x map-ont"
        " -a -o {output.sam}"
        " && python {input.filter_bin} {output.sam} {output.samf}"
        " && samtools sort {output.samf} -@ 8 -o {output.bam}"
rule minimapAll2GT:
    input:
        filter_bin = "src/filter_plasmid_sam.py", 
        ref= f"{refdir}/{{sample}}.fasta",
        ctgs = f"{outpath}/{{sample}}/qc/trim.lr.fastq.gz",
    output:
        sam=f"{outpath}/{{sample}}/qc/toplasmids.sam",
        samf=f"{outpath}/{{sample}}/qc/toplasmids_filtered.sam",
        bam=f"{outpath}/{{sample}}/qc/toplasmids.bam",
    threads:
        64
    shell:
        "minimap2"
        " {input.ref}"
        " {input.ctgs}"
        " -t {threads}"
        " -x map-ont"
        " -a -o {output.sam}"
        " && python {input.filter_bin} {output.sam} {output.samf}"
        " && samtools sort {output.samf} -@ 8 -o {output.bam}"
rule minimapSRCTG2GT:
    input:
        filter_bin = "src/filter_plasmid_sam.py", 
        ref=f"{refdir}/{{sample}}.fasta",
        ctgs = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/classify/result.plasmid.fasta",
    output:
        sam=temp(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/classify-qc/plasmid_predicted.sam"),
        samf=temp(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/classify-qc/plasmid_predicted_filtered.sam"),
        bam=f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/classify-qc/plasmid_predicted.bam",
    shell:
        "minimap2"
        " {input.ref}"
        " {input.ctgs}"
        " -t {threads}"
        " -x map-ont"
        " -a -o {output.sam}"
        " && python {input.filter_bin} {output.sam} {output.samf}"
        " && samtools sort {output.samf} -@ 8 -o {output.bam}"

rule minimap2GT_plus_unknown:
    input:
        filter_bin = "src/filter_plasmid_sam.py", 
        ref=f"{refdir}/{{sample}}.fasta",
        lr_plasmid = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.fastq.gz",
        lr_plasmid2 = lambda w: [f"{outpath}/{w.sample}/sra-{w.sra}/pcc-{w.pcc}/select-lr/plasmid.{i}.fastq.gz" for i in range(int(w.iter))],
        lr_unknown = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/unknown.fastq.gz",
    output:
        sam=temp(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected_i{{iter}}_pu.sam"),
        samf=temp(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected_i{{iter}}_pu_filtered.sam"),
        bam=f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected_i{{iter}}_pu.bam",
    threads:
        32
    shell:
        "minimap2"
        " {input.ref}"
        " {input.lr_plasmid}"
        " {input.lr_plasmid2}"
        " {input.lr_unknown}"
        " -t {threads}"
        " -x map-ont"
        " -a -o {output.sam}"
        " && python {input.filter_bin} {output.sam} {output.samf}"
        " && samtools sort {output.samf} -@ 8 -o {output.bam} && echo done"

from glob import glob
def get_extension_lrs(wc):
    fmt =f"{outpath}/{wc.sample}/hyplass_b/prop_lr/lr.round.{{}}.fastq.gz" 
    return [fmt.format(str(i)) for i in range(int(wc.iter)) if os.path.isfile( fmt.format(str(i))) ]
rule minimap2GT_single_script:
    input:
        filter_bin = "src/filter_plasmid_sam.py", 
        ref=f"{refdir}/{{sample}}.fasta",
        lr_plasmid = f"{outpath}/{{sample}}/hyplass_b/plasmid_long_reads/plasmid.fastq.gz",
        #lr_plasmid2 = lambda w:[f"{outpath}/{w.sample}/hyplass_b/prop_lr/lr.round.{i}.fastq.gz" for i in range(int(w.iter))],
        dir=directory(f"{outpath}/{{sample}}/hyplass_b/"),
    output:
        sam=temp(f"{outpath}/{{sample}}/hyplass_b_cov/plasmid_selected_i{{iter}}.sam"),
        samf=temp(f"{outpath}/{{sample}}/hyplass_b_cov/plasmid_selected_i{{iter}}_filtered.sam"),
        bam=f"{outpath}/{{sample}}/hyplass_b_cov/plasmid_selected_i{{iter}}.bam",
    threads:
        32
    params:
        extension=get_extension_lrs
    shell:
        "minimap2"
        " {input.ref}"
        " {input.lr_plasmid}"
        " {params.extension}"
        " -t {threads}"
        " -x map-ont"
        " -a -o {output.sam}"
        " && python {input.filter_bin} {output.sam} {output.samf}"
        " && samtools sort {output.samf} -@ 8 -o {output.bam}"


rule minimap2GT:
    input:
        filter_bin = "src/filter_plasmid_sam.py", 
        ref=f"{refdir}/{{sample}}.fasta",
        lr_plasmid = f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/select-lr/plasmid.fastq.gz",
        lr_plasmid2 = lambda w:[f"{outpath}/{w.sample}/sra-{w.sra}/pcc-{w.pcc}/select-lr/plasmid.{i}.fastq.gz" for i in range(int(w.iter))],
    output:
        sam=temp(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected_i{{iter}}.sam"),
        samf=temp(f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected_i{{iter}}_filtered.sam"),
        bam=f"{outpath}/{{sample}}/sra-{{sra}}/pcc-{{pcc}}/selection-qc/plasmid_selected_i{{iter}}.bam",
    threads:
        32
    shell:
        "minimap2"
        " {input.ref}"
        " {input.lr_plasmid}"
        " {input.lr_plasmid2}"
        " -t {threads}"
        " -x map-ont"
        " -a -o {output.sam}"
        " && python {input.filter_bin} {output.sam} {output.samf}"
        " && samtools sort {output.samf} -@ 8 -o {output.bam}"

rule CircularizeReferencePlasmids:
    input:
        f"{refdir}/{{sample}}.fasta",
    output:
        f"{outpath}/{{sample}}/GT/plasmid.circularized.gfa",
    run:
        with open(output[0], 'w') as hand:
            for name,head,seq in generate_fasta(input[0]):
                print(f"S\t{name}\t{seq}", file=hand)
                print(f"L\t{name}\t+\t{name}\t+\t0M", file=hand)
                print(f"L\t{name}\t-\t{name}\t-\t0M", file=hand)



rule bam2fq:
    input:
        f"{{sample}}.bam",
    output:
        f"{{sample}}.fq.gz",
    shell:
        "samtools fastq"
        " -1 /dev/null -2 /dev/null -s /dev/null"
        " -n {input}"
        " | pigz > {output}"


